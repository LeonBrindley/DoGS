%% Function: Evaluate the sub-struct State.Dependents.Optimiser.
function State = EvaluateOptimiser(State)
    %% 1. Clear the sub-struct State.Dependents.Optimiser.
    State.Dependents.Optimiser = struct;
    %% 2. Parse the fitting definitions associated with the current combination.
    Requirements = {'Any'};
    if(strcmp(State.Dependents.GapType, 'Soft'))
        Requirements{end + 1} = 'Soft';
    end
    Requirements{end + 1} = State.Dependents.Model;
    %% 3. Convert the initial values, lower bounds and upper bounds from structs into three arrays.
    State.Dependents.Optimiser.InitialValues = [];
    State.Dependents.Optimiser.LowerBounds = [];
    State.Dependents.Optimiser.UpperBounds = [];
    for idxRequirement = 1 : numel(Requirements)
        ParameterNames = fieldnames(State.Variables.FittingDefinitions.(Requirements{idxRequirement}));
        for idxParameter = 1 : numel(ParameterNames)
            FittingDefinition = State.Variables.FittingDefinitions.(Requirements{idxRequirement}).(ParameterNames{idxParameter});
            State.Dependents.Optimiser.InitialValues = [State.Dependents.Optimiser.InitialValues, reshape(FittingDefinition{2} ./ FittingDefinition{1}, 1, [])];
            State.Dependents.Optimiser.LowerBounds = [State.Dependents.Optimiser.LowerBounds, reshape(FittingDefinition{3} ./ FittingDefinition{1}, 1, [])];
            State.Dependents.Optimiser.UpperBounds = [State.Dependents.Optimiser.UpperBounds, reshape(FittingDefinition{4} ./ FittingDefinition{1}, 1, [])];
        end
    end
    %% 4. Configure the options associated with the solver in question.
    State.Dependents.Optimiser.HybridOptions = optimoptions('fmincon', ...
        'Display', 'off', ...
        'MaxIterations', State.Variables.Solvers.fmincon.MaxIterations, ...
        'MaxFunctionEvaluations', State.Variables.Solvers.fmincon.MaxFunctionEvaluations, ...
        'StepTolerance', State.Variables.Solvers.fmincon.StepTolerance, ...
        'OptimalityTolerance', State.Variables.Solvers.fmincon.OptimalityTolerance);
    switch State.Dependents.Solver
        case 'particleswarm'
            State.Dependents.Optimiser.Options = optimoptions('particleswarm', ...
                'Display', 'off', ...
                'MaxIterations', State.Variables.Solvers.particleswarm.MaxIterations, ...
                'MaxStallIterations', State.Variables.Solvers.particleswarm.MaxStallIterations, ...
                'FunctionTolerance', State.Variables.Solvers.particleswarm.FunctionTolerance, ...
                'HybridFcn', {@fmincon, State.Dependents.Optimiser.HybridOptions});
        case 'ga'
            State.Dependents.Optimiser.Options = optimoptions('ga', ...
                'Display', 'off', ...
                'MaxGenerations', State.Variables.Solvers.ga.MaxGenerations, ...
                'MaxStallGenerations', State.Variables.Solvers.ga.MaxStallGenerations, ...
                'PopulationSize', State.Variables.Solvers.ga.PopulationSize, ...
                'FunctionTolerance', State.Variables.Solvers.ga.FunctionTolerance, ...
                'HybridFcn', {@fmincon, State.Dependents.Optimiser.HybridOptions});
        case 'fmincon'
            State.Dependents.Optimiser.Options = State.Dependents.Optimiser.HybridOptions;
    end
    %% 5. Define the objective function to be minimised.

end